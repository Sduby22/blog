<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Partition Methods of Quicksort | Random Notes</title><meta name=keywords content="algorithm,sort"><meta name=description content="Generally speaking, Quicksort can use two types of partition methods. The first of which partitions the array into 3 parts: =(<=pivot), (pivot), (>pivot)=. And the latter partitions the array into 2 parts. I will introduce two coresponding algorithms: Hoare&rsquo;s and Lomuto partition algorithm."><meta name=author content="Sduby"><link rel=canonical href=https://chocole.top/posts/partition-methods-of-quicksort/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://chocole.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://chocole.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://chocole.top/favicon-32x32.png><link rel=apple-touch-icon href=https://chocole.top/apple-touch-icon.png><link rel=mask-icon href=https://chocole.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Partition Methods of Quicksort"><meta property="og:description" content="Generally speaking, Quicksort can use two types of partition methods. The first of which partitions the array into 3 parts: =(<=pivot), (pivot), (>pivot)=. And the latter partitions the array into 2 parts. I will introduce two coresponding algorithms: Hoare&rsquo;s and Lomuto partition algorithm."><meta property="og:type" content="article"><meta property="og:url" content="https://chocole.top/posts/partition-methods-of-quicksort/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-11T04:42:00+08:00"><meta property="article:modified_time" content="2022-07-11T04:42:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Partition Methods of Quicksort"><meta name=twitter:description content="Generally speaking, Quicksort can use two types of partition methods. The first of which partitions the array into 3 parts: =(<=pivot), (pivot), (>pivot)=. And the latter partitions the array into 2 parts. I will introduce two coresponding algorithms: Hoare&rsquo;s and Lomuto partition algorithm."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://chocole.top/posts/"},{"@type":"ListItem","position":2,"name":"Partition Methods of Quicksort","item":"https://chocole.top/posts/partition-methods-of-quicksort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Partition Methods of Quicksort","name":"Partition Methods of Quicksort","description":"Generally speaking, Quicksort can use two types of partition methods. The first of which partitions the array into 3 parts: =(\u0026lt;=pivot), (pivot), (\u0026gt;pivot)=. And the latter partitions the array into 2 parts. I will introduce two coresponding algorithms: Hoare\u0026rsquo;s and Lomuto partition algorithm.","keywords":["algorithm","sort"],"articleBody":"Generally speaking, Quicksort can use two types of partition methods. The first of which partitions the array into 3 parts: (\u003c=pivot), (pivot), (\u003epivot). And the latter partitions the array into 2 parts. I will introduce two coresponding algorithms: Hoare’s and Lomuto partition algorithm.\nLomuto Partition Algorithm Lomuto Partition Algorithm is very likely to be the partition algorithm that you learn from books. It partitions the array into three parts:\nFirst subset: less or equal than pivot Second subset: One element, equals pivot Third subset: greater than pivot The special thing is that after you’ve done the partitioning, the single element in the second subset (the pivot) is guaranteed to be located at the correct order position. (Why?)\nint partition(int* vec, int l, int r) { int k = l+1; int pivot_pos = l + rand() % (r-l); int pivot = vec[pivot_pos]; swap(vec[l], vec[pivot_pos]); for (int i = l+1; i != r; i++) { if (vec[i] \u003c= pivot) { swap(vec[k++], vec[i]); } } swap(vec[k-1], vec[l]); return k-1; } When use Lomuto Partition Algorithm with quicksort, make sure you don’t touch the middle(pivot) element, because it’s already been placed at the corrent position.\nvoid Qsort_r(int* vec, int l, int r) { if (l+1 \u003e= r) return; auto mid = partition(vec, l, r); Qsort_r(vec, l, mid); Qsort_r(vec, mid+1, r); // dont touch the mid(pivot) because it's already placed at the corrent pos! } Hoare’s Partition Algorithm Hoare’s Partition Algorithm basically partitions the array into two parts:\nThe first \\([left, mid)\\) subset is less or equal to pivot The second \\([mid, right)\\) subset is greater or equal to pivot Think: If elements with the same value as the pivot(let’s say \\(p\\)) appear multiple times in the array, does it mean that \\(p\\) will appear in both two subsets? If so, can we still use it in quicksort algorithm? Why? Does Lomuto Algorithm have this problem?\nint partition(int* vec, int l, int r) { int pivot_pos = l + rand() % (r-l); int pivot = vec[pivot_pos]; int i = l, j = r-1; while(i \u003c= j) { while(vec[i] \u003c pivot) i++; while(vec[j] \u003e pivot) j--; if (i \u003c= j) { swap(vec[i], vec[j]); i++; j--; } } return i; } When use Hoare’s Partition Algorithm with quicksort, make sure you do qsort recursively to two continuous subsets.\nvoid Qsort_r(int* vec, int l, int r) { if (l+1 \u003e= r) return; auto mid = partition(vec, l, r); Qsort_r(vec, l, mid); Qsort_r(vec, mid, r); } Think: If you pick a pivot in advance, partition the rest \\(n-1\\) elements with Hoare’s method, and finally swap the pivot back to mid place, then use the same Qsort_r function as the Lomuto method(don’t touch mid). Will it yield the right result? Why not and which step leads to problem?\n","wordCount":"458","inLanguage":"en","datePublished":"2022-07-11T04:42:00+08:00","dateModified":"2022-07-11T04:42:00+08:00","author":[{"@type":"Person","name":"Sduby"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://chocole.top/posts/partition-methods-of-quicksort/"},"publisher":{"@type":"Organization","name":"Random Notes","logo":{"@type":"ImageObject","url":"https://chocole.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://chocole.top/ accesskey=h title="Random Notes (Alt + H)">Random Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://chocole.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://chocole.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://chocole.top/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://chocole.top/>Home</a>&nbsp;»&nbsp;<a href=https://chocole.top/posts/>Posts</a></div><h1 class=post-title>Partition Methods of Quicksort</h1><div class=post-meta><span title='2022-07-11 04:42:00 +0800 +0800'>July 11, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Sduby</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#lomuto-partition-algorithm aria-label="Lomuto Partition Algorithm">Lomuto Partition Algorithm</a></li><li><a href=#hoare-s-partition-algorithm aria-label="Hoare&amp;rsquo;s Partition Algorithm">Hoare&rsquo;s Partition Algorithm</a></li></ul></div></details></div><div class=post-content><p>Generally speaking, Quicksort can use two types of partition methods. The first of which partitions the array into 3 parts: <code>(&lt;=pivot), (pivot), (>pivot)</code>. And the latter partitions the array into 2 parts. I will introduce two coresponding algorithms: Hoare&rsquo;s and Lomuto partition algorithm.</p><h2 id=lomuto-partition-algorithm>Lomuto Partition Algorithm<a hidden class=anchor aria-hidden=true href=#lomuto-partition-algorithm>#</a></h2><p>Lomuto Partition Algorithm is very likely to be the partition algorithm that you learn from books. It partitions the array into three parts:</p><ul><li>First subset: <strong>less or equal than</strong> <code>pivot</code></li><li>Second subset: One element, <strong>equals</strong> <code>pivot</code></li><li>Third subset: <strong>greater than</strong> <code>pivot</code></li></ul><p>The special thing is that after you&rsquo;ve done the partitioning, the single element in the second subset (the pivot) is guaranteed to be located at the correct order position. (<em>Why?</em>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> vec, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot_pos <span style=color:#f92672>=</span> l <span style=color:#f92672>+</span> rand() <span style=color:#f92672>%</span> (r<span style=color:#f92672>-</span>l);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> vec[pivot_pos];
</span></span><span style=display:flex><span>    swap(vec[l], vec[pivot_pos]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>!=</span> r; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (vec[i] <span style=color:#f92672>&lt;=</span> pivot) {
</span></span><span style=display:flex><span>            swap(vec[k<span style=color:#f92672>++</span>], vec[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    swap(vec[k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], vec[l]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When use <a href=#lomuto-partition-algorithm>Lomuto Partition Algorithm</a> with quicksort, make sure you don&rsquo;t touch the middle(pivot) element, because it&rsquo;s already been placed at the corrent position.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Qsort_r</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> vec, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> r) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> mid <span style=color:#f92672>=</span> partition(vec, l, r);
</span></span><span style=display:flex><span>    Qsort_r(vec, l, mid);
</span></span><span style=display:flex><span>    Qsort_r(vec, mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, r); <span style=color:#75715e>// dont touch the mid(pivot) because it&#39;s already placed at the corrent pos!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=hoare-s-partition-algorithm>Hoare&rsquo;s Partition Algorithm<a hidden class=anchor aria-hidden=true href=#hoare-s-partition-algorithm>#</a></h2><p>Hoare&rsquo;s Partition Algorithm basically partitions the array into two parts:</p><ul><li>The first \([left, mid)\) subset is <strong>less or equal to</strong> <code>pivot</code></li><li>The second \([mid, right)\) subset is <strong>greater or equal to</strong> <code>pivot</code></li></ul><blockquote><p><strong>Think: If elements with the same value as the pivot(let&rsquo;s say \(p\)) appear multiple times in the array, does it mean that \(p\) will appear in both two subsets? If so, can we still use it in quicksort algorithm? Why? Does Lomuto Algorithm have this problem?</strong></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> vec, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot_pos <span style=color:#f92672>=</span> l <span style=color:#f92672>+</span> rand() <span style=color:#f92672>%</span> (r<span style=color:#f92672>-</span>l);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> vec[pivot_pos];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> l, j <span style=color:#f92672>=</span> r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(vec[i] <span style=color:#f92672>&lt;</span> pivot) i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(vec[j] <span style=color:#f92672>&gt;</span> pivot) j<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;=</span> j) {
</span></span><span style=display:flex><span>            swap(vec[i], vec[j]);
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>; j<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> i;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When use <a href=#hoare-s-partition-algorithm>Hoare&rsquo;s Partition Algorithm</a> with quicksort, make sure you do qsort recursively to two continuous subsets.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Qsort_r</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> vec, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> r) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> mid <span style=color:#f92672>=</span> partition(vec, l, r);
</span></span><span style=display:flex><span>    Qsort_r(vec, l, mid);
</span></span><span style=display:flex><span>    Qsort_r(vec, mid, r);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><strong>Think: If you pick a pivot in advance, partition the rest \(n-1\) elements with Hoare&rsquo;s method, and finally swap the pivot back to <code>mid</code> place, then use the same <code>Qsort_r</code> function as the Lomuto method(don&rsquo;t touch <code>mid</code>). Will it yield the right result? Why not and which step leads to problem?</strong></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://chocole.top/tags/algorithm/>algorithm</a></li><li><a href=https://chocole.top/tags/sort/>sort</a></li></ul><nav class=paginav><a class=next href=https://chocole.top/posts/todo-build-a-website-with-hugo+github-pages+cloudflare/><span class=title>Next »</span><br><span>Build a website with Hugo & Github Pages & Cloudflare</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://chocole.top/>Random Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>